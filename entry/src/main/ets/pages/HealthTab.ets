// HealthTab.ets - ç”¨æˆ·å¥åº· Tabï¼ˆçº¯ UI é™æ€å ä½ç‰ˆï¼‰
//
// âœ… ç›®æ ‡ï¼šå…ˆæŠŠé¡µé¢ç»“æ„/å¸ƒå±€æ­å¥½ï¼ˆæ ‡é¢˜ + ç”¨æˆ·ä¸‹æ‹‰é€‰æ‹© + å¤šå¼ å¥åº·æ•°æ®å¡ç‰‡ï¼‰
// - æš‚ä¸æ¥å…¥ç»˜å›¾/ç½‘ç»œ/å­˜å‚¨ï¼Œæ‰€æœ‰æ•°æ®ä½¿ç”¨é™æ€ mock
// - UI é£æ ¼å°½é‡å¯¹é½ä½ ç»™çš„ ArchiveTabï¼šé¡¶éƒ¨æ ‡é¢˜æ  + å†…å®¹åŒºæ ‡é¢˜å¸¦ä¸‹åˆ’çº¿ + å¡ç‰‡åœ†è§’/æµ…ç°èƒŒæ™¯/è¾¹æ¡†
//
// ğŸ§© äº¤äº’ï¼š
// - ä½¿ç”¨ Select ä¸‹æ‹‰é€‰æ‹©ç”¨æˆ·
// - é€‰æ‹©ä¸åŒç”¨æˆ·åï¼Œæ›´æ–°é¡µé¢å±•ç¤ºçš„é™æ€æ•°æ®ï¼ˆå ä½æ–‡å­—ï¼‰
//
// âš ï¸ æ³¨æ„ï¼š
// - è¯¥ Tab ä¸€èˆ¬ç”± MainTabPage å¼•ç”¨ï¼Œå› æ­¤ä¸åŠ  @Entry
// - å¦‚æœä½ å¸Œæœ›å®ƒå•ç‹¬è¿è¡Œæµ‹è¯•ï¼Œå†åŠ  @Entry å³å¯

import router from '@ohos.router';
import { HealthData, HealthDataManager, User } from '../model/HealthData';

class SelectOption {
  value: string;

  constructor(value: string) {
    this.value = value;
  }
}

class HealthUiSnapshot {
  heartRateText: string;   // å¿ƒç‡
  spo2Text: string;        // è¡€æ°§
  tempText: string;        // ä½“æ¸©
  glucoseText: string;     // è¡€ç³–
  bpText: string;          // è¡€å‹
  stressText: string;      // å‹åŠ›
  sleepText: string;       // ç¡çœ 
  updatedText: string;     // æ›´æ–°æ—¶é—´

  constructor(
    heartRateText: string,
    spo2Text: string,
    tempText: string,
    glucoseText: string,
    bpText: string,
    stressText: string,
    sleepText: string,
    updatedText: string
  ) {
    this.heartRateText = heartRateText;
    this.spo2Text = spo2Text;
    this.tempText = tempText;
    this.glucoseText = glucoseText;
    this.bpText = bpText;
    this.stressText = stressText;
    this.sleepText = sleepText;
    this.updatedText = updatedText;
  }
}

class ChartPoint {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

class HealthDetailRouteParams {
  type: string;
  userId?: number;

  constructor(type: string, userId?: number) {
    this.type = type;
    if (userId !== undefined) {
      this.userId = userId;
    }
  }
}

/**
 * é€šç”¨å¡ç‰‡ï¼ˆå°å¡ç‰‡ï¼‰ï¼šé¢œè‰²å— + æ ‡é¢˜ + å€¼ï¼ˆå ä½ï¼‰
 */
@Component
struct HealthSmallCard {
  @Prop title: string;
  @Prop value: string;
  @Prop blockColor: number = 0xFFEAF7F2; // é»˜è®¤æµ…ç»¿å—
  @Prop useImage: boolean = false;
  @Prop image: Resource = $r('app.media.health_example1');
  @Prop barValues: number[] = [];
  @Prop barColor: number = 0xFF2FB86E;
  @Prop @Watch('onBarRefreshChanged') barRefreshSeed: number = 0;
  private barCtx: CanvasRenderingContext2D = new CanvasRenderingContext2D();
  private barReady: boolean = false;

  private onBarRefreshChanged(): void {
    if (!this.barReady) {
      return;
    }
    this.drawBars(this.barCtx);
  }

  build() {
    Column() {
      // é¡¶éƒ¨ï¼šæ ‡é¢˜
      Text(this.title)
        .fontSize(14)
        .fontColor(0xFF666666)
        .margin({ bottom: 6 })

      // ä¸­éƒ¨ï¼šå€¼
      Text(this.value)
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .fontColor(0xFF333333)
        .margin({ bottom: 10 })

      // åº•éƒ¨ï¼šé¢œè‰²å—å ä½ / å›¾ç‰‡ç¤ºä¾‹
      if (this.useImage) {
        Image(this.image)
          .width('100%')
          .objectFit(ImageFit.Cover)
          .borderRadius(10)
        .backgroundColor(this.blockColor)
        .borderRadius(10)
        .clip(true)
      } else if (this.barValues.length > 0) {
        Canvas(this.barCtx)
          .width('100%')
          .height(70)
          .borderRadius(10)
          .backgroundColor(this.blockColor)
          .clip(true)
          .onReady(() => {
            this.barReady = true;
            this.drawBars(this.barCtx);
          })
      } else {
        Row()
          .width('100%')
          .height(46)
          .backgroundColor(this.blockColor)
          .borderRadius(10)
      }
    }
    .padding({ top : 12, bottom : 4 })
    .borderRadius(12)
    .backgroundColor(0xFFFFFFFF)
    .borderWidth(1)
    .borderColor(0x1A000000)
  }

  private drawBars(ctx: CanvasRenderingContext2D): void {
    const width: number = ctx.width;
    const height: number = ctx.height;
    const paddingX: number = 10;
    const paddingY: number = 8;

    const values: number[] = this.getSafeBarValues();
    let minVal: number = values[0];
    let maxVal: number = values[0];
    for (let i = 1; i < values.length; i++) {
      if (values[i] < minVal) {
        minVal = values[i];
      }
      if (values[i] > maxVal) {
        maxVal = values[i];
      }
    }
    if (maxVal - minVal < 1) {
      maxVal = minVal + 1;
    }

    ctx.clearRect(0, 0, width, height);

    const barAreaWidth: number = width - paddingX * 2;
    const slotWidth: number = barAreaWidth / values.length;
    const barWidth: number = Math.max(6, slotWidth * 0.32);
    const baseY: number = height - paddingY;
    const barMaxHeight: number = height - paddingY * 2 - 10;

    for (let i = 0; i < values.length; i++) {
      const ratio: number = (values[i] - minVal) / (maxVal - minVal);
      const barHeight: number = Math.max(8, ratio * barMaxHeight);
      const x: number = paddingX + slotWidth * i + (slotWidth - barWidth) / 2;
      const y: number = baseY - barHeight;

      ctx.fillStyle = this.barColor;
      ctx.fillRect(x, y, barWidth, barHeight);

      ctx.fillStyle = '#FF6A6A';
      ctx.font = '10vp sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(values[i].toString(), x + barWidth / 2, y - 2);
    }
  }

  private getSafeBarValues(): number[] {
    if (this.barValues.length > 0) {
      return this.barValues;
    }
    return [0, 0, 0, 0];
  }
}

/**
 * å°å¡ç‰‡æ›²çº¿å›¾ï¼šç”¨äºç¡çœ ç­‰å°å°ºå¯¸æ›²çº¿å±•ç¤º
 */
@Component
struct HealthSmallLineCard {
  @Prop title: string;
  @Prop value: string;
  @Prop blockColor: number = 0xFFEAF7F2;
  @Prop lineValues: number[] = [];
  @Prop lineColor: number = 0xFF2FB86E;
  @Prop @Watch('onLineRefreshChanged') lineRefreshSeed: number = 0;
  private lineCtx: CanvasRenderingContext2D = new CanvasRenderingContext2D();
  private lineReady: boolean = false;

  private onLineRefreshChanged(): void {
    if (!this.lineReady) {
      return;
    }
    this.drawLine(this.lineCtx);
  }

  build() {
    Column() {
      Text(this.title)
        .fontSize(14)
        .fontColor(0xFF666666)
        .margin({ bottom: 6 })

      Text(this.value)
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .fontColor(0xFF333333)
        .margin({ bottom: 10 })

      Canvas(this.lineCtx)
        .width('100%')
        .height(70)
        .borderRadius(10)
        .backgroundColor(this.blockColor)
        .clip(true)
        .onReady(() => {
          this.lineReady = true;
          this.drawLine(this.lineCtx);
        })
    }
    .alignItems(HorizontalAlign.Start)
    .padding({ top: 12, bottom: 4 })
    .borderRadius(12)
    .backgroundColor(0xFFFFFFFF)
    .borderWidth(1)
    .borderColor(0x1A000000)
  }

  private drawLine(ctx: CanvasRenderingContext2D): void {
    const width: number = ctx.width;
    const height: number = ctx.height;
    const paddingX: number = 8;
    const paddingY: number = 10;

    const values: number[] = this.getSafeLineValues();
    let minVal: number = values[0];
    let maxVal: number = values[0];
    for (let i = 1; i < values.length; i++) {
      if (values[i] < minVal) {
        minVal = values[i];
      }
      if (values[i] > maxVal) {
        maxVal = values[i];
      }
    }
    if (maxVal - minVal < 1) {
      maxVal = minVal + 1;
    }

    ctx.clearRect(0, 0, width, height);

    const stepX: number = (width - paddingX * 2) / (values.length - 1);
    const chartHeight: number = height - paddingY * 2;
    const points: ChartPoint[] = [];
    for (let i = 0; i < values.length; i++) {
      const ratio: number = (values[i] - minVal) / (maxVal - minVal);
      const x = paddingX + stepX * i;
      const y = height - paddingY - ratio * chartHeight;
      points.push(new ChartPoint(x, y));
    }

    // å¡«å……åŒºåŸŸ
    this.buildCurvePath(ctx, points);
    ctx.lineTo(points[points.length - 1].x, height - paddingY);
    ctx.lineTo(points[0].x, height - paddingY);
    ctx.closePath();

    const fill = ctx.createLinearGradient(0, 0, 0, height);
    fill.addColorStop(0, 'rgba(46, 199, 168, 0.35)');
    fill.addColorStop(1, 'rgba(46, 199, 168, 0)');
    ctx.fillStyle = fill;
    ctx.fill();

    // æŠ˜çº¿æè¾¹
    this.buildCurvePath(ctx, points);
    ctx.strokeStyle = this.toHexColor(this.lineColor);
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();

    // èŠ‚ç‚¹æ•°å€¼
    ctx.fillStyle = this.toHexColor(this.lineColor);
    ctx.font = '10vp sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      ctx.beginPath();
      ctx.arc(point.x, point.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillText(values[i].toString(), point.x, point.y - 4);
    }
  }

  private buildCurvePath(ctx: CanvasRenderingContext2D, points: ChartPoint[]): void {
    if (points.length < 2) {
      return;
    }
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 0; i < points.length - 1; i++) {
      const p0: ChartPoint = i > 0 ? points[i - 1] : points[i];
      const p1: ChartPoint = points[i];
      const p2: ChartPoint = points[i + 1];
      const p3: ChartPoint = i + 2 < points.length ? points[i + 2] : p2;

      const cp1 = new ChartPoint(
        p1.x + (p2.x - p0.x) / 6,
        p1.y + (p2.y - p0.y) / 6
      );
      const cp2 = new ChartPoint(
        p2.x - (p3.x - p1.x) / 6,
        p2.y - (p3.y - p1.y) / 6
      );

      ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
    }
  }

  private getSafeLineValues(): number[] {
    if (this.lineValues.length > 1) {
      return this.lineValues;
    }
    const fallback: number = this.lineValues.length === 1 ? this.lineValues[0] : 0;
    return [fallback, fallback];
  }

  private toHexColor(color: number): string {
    const hex: string = color.toString(16).padStart(8, '0').toUpperCase();
    return `#${hex}`;
  }
}

/**
 * é€šç”¨å¡ç‰‡ï¼ˆå¤§å¡ç‰‡ï¼‰ï¼šç”¨äºé¡¶éƒ¨â€œå¿ƒç‡â€ç±»ä¼¼çš„å¤§å—å±•ç¤º
 */
@Component
struct HealthLargeCard {
  @Prop title: string;
  @Prop value: string;
  @Prop subtitle: string = '';
  @Prop blockColor: number = 0xFFF8EAEA; // é»˜è®¤æµ…çº¢å—
  @Prop chartValues: number[] = [];
  @Prop @Watch('onRefreshSeedChanged') refreshSeed: number = 0;
  private ctx: CanvasRenderingContext2D = new CanvasRenderingContext2D();
  private ready: boolean = false;

  private onRefreshSeedChanged(): void {
    if (!this.ready) {
      return;
    }
    this.drawHeartRate(this.ctx);
  }

  build() {
    Column() {
      Row() {
        Column() {
          Text(this.title)
            .fontSize(14)
            .fontColor(0xFF666666)

          Text(this.value)
            .fontSize(22)
            .fontWeight(FontWeight.Bold)
            .fontColor(0xFF333333)
            .margin({ top: 6 })
        }
        .alignItems(HorizontalAlign.Start)

        Blank().layoutWeight(1)

        // å³ä¸Šè§’ï¼šæ›´æ–°æ—¶é—´å ä½
        if (this.subtitle.length > 0) {
          Text(this.subtitle)
            .fontSize(12)
            .fontColor(0xFF999999)
        }
      }
      .margin({ bottom: 10 })

      // å¿ƒç‡æ›²çº¿ Canvas
      Canvas(this.ctx)
        .width('100%')
        .height(90)
        .borderRadius(12)
        .onReady(() => {
          this.ready = true;
          this.drawHeartRate(this.ctx);
        })
    }
    .alignItems(HorizontalAlign.Start)
    .padding(12)
    .borderRadius(12)
    .backgroundColor(0xFFFFFFFF)
    .borderWidth(1)
    .borderColor(0x1A000000)
  }

  private drawHeartRate(ctx: CanvasRenderingContext2D): void {
    const width: number = ctx.width;
    const height: number = ctx.height;
    const paddingX: number = 8;
    const paddingY: number = 10;

    let values: number[] = [];
    if (this.chartValues.length > 0) {
      values = this.chartValues.slice(0);
    } else {
      const baseValue: number = this.parseHeartRate(this.value);
      const safeBase: number = baseValue > 0 ? baseValue : 78;
      values = [
        safeBase + 6,
        safeBase - 12,
        safeBase + 10,
        safeBase
      ];
    }
    if (values.length < 2) {
      const fallback: number = values.length > 0 ? values[0] : 78;
      while (values.length < 2) {
        values.push(fallback);
      }
    }

    let minVal: number = values[0];
    let maxVal: number = values[0];
    for (let i = 1; i < values.length; i++) {
      if (values[i] < minVal) {
        minVal = values[i];
      }
      if (values[i] > maxVal) {
        maxVal = values[i];
      }
    }
    if (maxVal - minVal < 1) {
      maxVal = minVal + 1;
    }

    ctx.clearRect(0, 0, width, height);

    // èƒŒæ™¯æ¸å˜
    const background = ctx.createLinearGradient(0, 0, 0, height);
    background.addColorStop(0, '#FFEDEE');
    background.addColorStop(1, '#FFFFFF');
    ctx.fillStyle = background;
    ctx.fillRect(0, 0, width, height);

    const stepX: number = (width - paddingX * 2) / (values.length - 1);
    const chartHeight: number = height - paddingY * 2;
    const points: ChartPoint[] = [];
    for (let i = 0; i < values.length; i++) {
      const ratio: number = (values[i] - minVal) / (maxVal - minVal);
      const x = paddingX + stepX * i;
      const y = height - paddingY - ratio * chartHeight;
      points.push(new ChartPoint(x, y));
    }

    // å¡«å……åŒºåŸŸ
    this.buildCurvePath(ctx, points);
    ctx.lineTo(points[points.length - 1].x, height - paddingY);
    ctx.lineTo(points[0].x, height - paddingY);
    ctx.closePath();

    const fill = ctx.createLinearGradient(0, 0, 0, height);
    fill.addColorStop(0, 'rgba(255, 92, 92, 0.35)');
    fill.addColorStop(1, 'rgba(255, 92, 92, 0)');
    ctx.fillStyle = fill;
    ctx.fill();

    // æŠ˜çº¿æè¾¹
    this.buildCurvePath(ctx, points);
    ctx.strokeStyle = '#FF5C5C';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();

    // èŠ‚ç‚¹ä¸æ•°å€¼
    ctx.fillStyle = '#FF5C5C';
    ctx.font = '12vp sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      ctx.beginPath();
      ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillText(values[i].toString(), point.x, point.y - 6);
    }
  }

  private buildCurvePath(ctx: CanvasRenderingContext2D, points: ChartPoint[]): void {
    if (points.length < 2) {
      return;
    }
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 0; i < points.length - 1; i++) {
      const p0: ChartPoint = i > 0 ? points[i - 1] : points[i];
      const p1: ChartPoint = points[i];
      const p2: ChartPoint = points[i + 1];
      const p3: ChartPoint = i + 2 < points.length ? points[i + 2] : p2;

      const cp1 = new ChartPoint(
        p1.x + (p2.x - p0.x) / 6,
        p1.y + (p2.y - p0.y) / 6
      );
      const cp2 = new ChartPoint(
        p2.x - (p3.x - p1.x) / 6,
        p2.y - (p3.y - p1.y) / 6
      );

      ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
    }
  }

  private parseHeartRate(text: string): number {
    let numStr = '';
    for (let i = 0; i < text.length; i++) {
      const ch = text.charAt(i);
      if (ch >= '0' && ch <= '9') {
        numStr += ch;
      } else if (numStr.length > 0) {
        break;
      }
    }
    if (numStr.length === 0) {
      return 0;
    }
    return Number(numStr);
  }
}

@Component
export default struct HealthTab {
  /** ç”¨æˆ·åˆ—è¡¨ï¼ˆæ¥è‡ª HealthDataï¼Œåç»­å¯æ”¹æˆä» KvStore è¯»å–æ¡£æ¡ˆç”¨æˆ·ï¼‰ */
  @State private users: User[] = [];
  // ä¸‹æ‹‰é€‰é¡¹ï¼ˆå‚ç…§ ServiceReservationPage çš„ Select å†™æ³•ï¼‰
  @State private userOptions: SelectOption[] = [];

  /** å½“å‰é€‰ä¸­çš„ç”¨æˆ·ä¸‹æ ‡ï¼ˆç”¨äº UI å±•ç¤ºä¸æ•°æ®åˆ‡æ¢ï¼‰ */
  @State private selectedIndex: number = 0;

  /** å½“å‰å±•ç¤ºçš„å¥åº·æ•°æ®ï¼ˆé™æ€å ä½ï¼‰ */
  @State private snapshot: HealthUiSnapshot = new HealthUiSnapshot('', '', '', '', '', '', '', '');
  /** å½“å‰å¿ƒç‡æ›²çº¿æ•°æ® */
  @State private heartRateValues: number[] = [];
  /** è§¦å‘æ›²çº¿é‡ç»˜çš„æ ‡è®° */
  @State private heartRateSeed: number = 0;
  /** è¡€æ°§æŸ±çŠ¶å›¾æ•°æ® */
  @State private spo2Bars: number[] = [];
  /** å‹åŠ›æŸ±çŠ¶å›¾æ•°æ® */
  @State private stressBars: number[] = [];
  /** ç¡çœ æ›²çº¿æ•°æ® */
  @State private sleepValues: number[] = [];
  /** è§¦å‘æŸ±çŠ¶å›¾é‡ç»˜ */
  @State private barSeed: number = 0;
  /** è§¦å‘ç¡çœ æ›²çº¿é‡ç»˜ */
  @State private sleepSeed: number = 0;

  aboutToAppear(): void {
    this.users = HealthDataManager.getUsers();
    this.userOptions = this.users.map((item: User) => {
      return new SelectOption(item.name);
    });
    this.applySnapshotByIndex(0);
  }

  /**
   * å¥åº·æ•°æ®è¾…åŠ©æ–¹æ³•
   */
  private getLatestHealthValue(userId: number, type: string): HealthData | null {
    const list: HealthData[] = HealthDataManager.getHealthData(userId, type);
    if (list.length === 0) {
      return null;
    }
    return list[list.length - 1];
  }

  private formatHealthValue(data: HealthData | null, fallback: string): string {
    if (data === null) {
      return fallback;
    }
    const value: string = data.value;
    const unit: string = data.unit ? data.unit : '';
    if (unit.length > 0 && value.indexOf(unit) < 0) {
      return `${value} ${unit}`;
    }
    return value;
  }

  private buildSnapshotForUser(userId: number): HealthUiSnapshot {
    const heartRate: HealthData | null = this.getLatestHealthValue(userId, 'å¿ƒç‡');
    const spo2: HealthData | null = this.getLatestHealthValue(userId, 'è¡€æ°§');
    const temp: HealthData | null = this.getLatestHealthValue(userId, 'ä½“æ¸©');
    const glucose: HealthData | null = this.getLatestHealthValue(userId, 'è¡€ç³–');
    const bp: HealthData | null = this.getLatestHealthValue(userId, 'è¡€å‹');
    const sleep: HealthData | null = this.getLatestHealthValue(userId, 'ç¡çœ ');
    const stress: HealthData | null = this.getLatestHealthValue(userId, 'å‹åŠ›');

    const updatedText: string = heartRate ? heartRate.measurementTime : 'åˆšåˆšæ›´æ–°';

    return new HealthUiSnapshot(
      this.formatHealthValue(heartRate, '--'),
      this.formatHealthValue(spo2, '--'),
      this.formatHealthValue(temp, '--'),
      this.formatHealthValue(glucose, '--'),
      this.formatHealthValue(bp, '--'),
      this.formatHealthValue(stress, '--'),
      this.formatHealthValue(sleep, '--'),
      updatedText
    );
  }

  private parseNumber(value: string): number {
    let numStr: string = '';
    for (let i = 0; i < value.length; i++) {
      const ch = value.charAt(i);
      if ((ch >= '0' && ch <= '9') || ch === '.') {
        numStr += ch;
      } else if (numStr.length > 0) {
        break;
      }
    }
    if (numStr.length === 0) {
      return 0;
    }
    return Number(numStr);
  }

  private getHeartRateSeries(userId: number): number[] {
    const list: HealthData[] = HealthDataManager.getHealthData(userId, 'å¿ƒç‡');
    const values: number[] = [];
    for (let i = 0; i < list.length; i++) {
      const parsed: number = this.parseNumber(list[i].value);
      if (parsed > 0) {
        values.push(parsed);
      }
    }
    return values;
  }

  private getBarSeries(userId: number, type: string): number[] {
    const list: HealthData[] = HealthDataManager.getHealthData(userId, type);
    const values: number[] = [];
    for (let i = 0; i < list.length; i++) {
      const parsed: number = this.parseNumber(list[i].value);
      if (parsed > 0) {
        values.push(parsed);
      }
    }
    if (values.length === 0) {
      return [];
    }
    const maxCount: number = 4;
    const startIndex: number = Math.max(0, values.length - maxCount);
    return values.slice(startIndex);
  }

  private getLineSeries(userId: number, type: string): number[] {
    const list: HealthData[] = HealthDataManager.getHealthData(userId, type);
    const values: number[] = [];
    for (let i = 0; i < list.length; i++) {
      const parsed: number = this.parseNumber(list[i].value);
      if (parsed > 0) {
        values.push(parsed);
      }
    }
    return values;
  }

  /**
   * æ ¹æ®ç”¨æˆ·ä¸‹æ ‡åˆ‡æ¢æ•°æ®
   * - çœŸå®é¡¹ç›®ï¼šè¿™é‡Œå¯ä»¥æ”¹æˆ await load(userId) å† this.snapshot = xxx
   */
  private applySnapshotByIndex(index: number): void {
    if (this.users.length === 0) {
      return;
    }
    const safeIndex: number = Math.max(0, Math.min(index, this.users.length - 1));
    this.selectedIndex = safeIndex;

    const userId: number = this.users[safeIndex].id;
    this.snapshot = this.buildSnapshotForUser(userId);
    this.heartRateValues = this.getHeartRateSeries(userId);
    this.heartRateSeed++;
    this.spo2Bars = this.getBarSeries(userId, 'è¡€æ°§');
    this.stressBars = this.getBarSeries(userId, 'å‹åŠ›');
    this.barSeed++;
    this.sleepValues = this.getLineSeries(userId, 'ç¡çœ ');
    this.sleepSeed++;
  }

  private openHealthDetail(type: string): void {
    let userId: number | undefined = undefined;
    if (this.users.length > 0 && this.selectedIndex >= 0 && this.selectedIndex < this.users.length) {
      userId = this.users[this.selectedIndex].id;
    }
    const params: HealthDetailRouteParams = new HealthDetailRouteParams(type, userId);
    router.pushUrl({
      url: 'pages/HealthDetailPage',
      params: params
    });
  }

  build() {
    Column() {
      // 1) é¡¶éƒ¨æ ‡é¢˜æ ï¼ˆå›ºå®šé«˜åº¦ï¼Œé£æ ¼å¯¹é½ ArchiveTabï¼‰
      Row() {
        Text('å¥åº·')
          .fontSize($r('app.float.home_header_title_font_size'))
          .fontWeight(FontWeight.Normal)
          .fontColor(0xFFFFFFFF)
      }
      .height($r('app.float.home_header_height'))
      .margin({ bottom: 5 })
      .justifyContent(FlexAlign.Center)
      .alignItems(VerticalAlign.Center)

      // 2) æ»šåŠ¨å†…å®¹åŒº
      Scroll() {
        Column() {
          // ---------- é¡µé¢æ ‡é¢˜ï¼šç”¨æˆ·å¥åº· + ä¸‹åˆ’çº¿ ----------
          Row() {
            Column() {
              Text('ç”¨æˆ·å¥åº·')
                .fontSize(28)
                .fontWeight(FontWeight.Bold)
                .fontColor(0xFF333333)

              // ä¸‹åˆ’çº¿ï¼ˆä»æ–‡å­—å¼€å¤´å¼€å§‹ï¼‰
              Row()
                .width(84)
                .height(3)
                .backgroundColor(0xFF333333)
                .borderRadius(2)
                .margin({ top: 6 })
            }
            .alignItems(HorizontalAlign.Start)
            .margin({ left: $r('app.float.home_health_section_title_left_margin') })
          }
          .width('100%')
          .margin({ top: 20, bottom: 12 })
          .justifyContent(FlexAlign.Start)
          .alignItems(VerticalAlign.Center)

          Row() {
            // ä¸‹æ‹‰é€‰æ‹©ç”¨æˆ·
            Select(this.userOptions)
              .selected(this.selectedIndex)
              .value(
                this.userOptions.length > 0 && this.selectedIndex >= 0
                  ? this.userOptions[this.selectedIndex].value
                  : 'æš‚æ— ç”¨æˆ·'
              )
              .font({ size: 16 })
              .fontColor(0xFF333333)
              .onSelect((index: number, value: string) => {
                this.applySnapshotByIndex(index);
              })
          }
          .width('90%')
          .height(44)
          .padding({ left: 12, right: 12 })
          .backgroundColor(0xFFFFFFFF)
          .borderRadius(10)
          .borderWidth(1)
          .borderColor(0x1A000000)
          .margin({ bottom: 12 })
          // ---------- é¡¶éƒ¨å¤§å¡ç‰‡ï¼ˆå¿ƒç‡æŠ˜çº¿å ä½ï¼‰ ----------
          Column() {
            HealthLargeCard({
              title: 'å¿ƒç‡',
              value: this.snapshot.heartRateText,
              subtitle: this.snapshot.updatedText,
              blockColor: 0xFFF8EAEA,
              chartValues: this.heartRateValues,
              refreshSeed: this.heartRateSeed
            })
          }
          .onClick((): void => {
            this.openHealthDetail('å¿ƒç‡');
          })
          .width('90%')
          .margin({ bottom: 12 })

          // ---------- ä¸¤åˆ—å°å¡ç‰‡åŒºåŸŸï¼ˆé¢œè‰²å— + æ–‡å­—å ä½ï¼‰ ----------
          // ç¬¬ä¸€è¡Œ
          Row({ space: 12 }) {
            Column() {
              HealthSmallCard({
                title: 'è¡€æ°§é¥±å’Œåº¦',
                value: this.snapshot.spo2Text,
                blockColor: 0xFFEAF7F2,
                barValues: this.spo2Bars,
                barColor: 0xFF2FB86E,
                barRefreshSeed: this.barSeed
              })
            }
            .onClick((): void => {
              this.openHealthDetail('è¡€æ°§');
            })
            .layoutWeight(1)

            Column() {
              HealthSmallCard({
                title: 'ä½“æ¸©',
                value: this.snapshot.tempText,
                blockColor: 0xFFF3F0FF,
                useImage: true,
                image: $r('app.media.health_example1')
              })
            }
            .onClick((): void => {
              this.openHealthDetail('ä½“æ¸©');
            })
            .layoutWeight(1)
          }
          .width('90%')
          .margin({ bottom: 12 })

          // ç¬¬äºŒè¡Œ
          Row({ space: 12 }) {
            Column() {
              HealthSmallCard({
                title: 'è¡€ç³–',
                value: this.snapshot.glucoseText,
                blockColor: 0xFFFFF3E5,
                useImage: true,
                image: $r('app.media.health_example2')
              })
            }
            .onClick((): void => {
              this.openHealthDetail('è¡€ç³–');
            })
            .layoutWeight(1)

            Column() {
              HealthSmallCard({
                title: 'è¡€å‹',
                value: this.snapshot.bpText,
                blockColor: 0xFFF8EAEA,
                useImage: true,
                image: $r('app.media.health_example3')
              })
            }
            .onClick((): void => {
              this.openHealthDetail('è¡€å‹');
            })
            .layoutWeight(1)
          }
          .width('90%')
          .margin({ bottom: 12 })

          // ç¬¬ä¸‰è¡Œ
          Row({ space: 12 }) {
            Column() {
              HealthSmallCard({
                title: 'å‹åŠ›',
                value: this.snapshot.stressText,
                blockColor: 0xFFEAF7F2,
                barValues: this.stressBars,
                barColor: 0xFF2FB86E,
                barRefreshSeed: this.barSeed
              })
            }
            .onClick((): void => {
              this.openHealthDetail('å‹åŠ›');
            })
            .layoutWeight(1)

            Column() {
              HealthSmallLineCard({
                title: 'ç¡çœ ',
                value: this.snapshot.sleepText,
                blockColor: 0xFFEFF7FF,
                lineValues: this.sleepValues,
                lineColor: 0xFF2EC7A8,
                lineRefreshSeed: this.sleepSeed
              })
            }
            .onClick((): void => {
              this.openHealthDetail('ç¡çœ ');
            })
            .layoutWeight(1)
          }
          .width('90%')
          .margin({ bottom: 18 })

          // åº•éƒ¨ç•™ç™½ï¼šé¿å…å†…å®¹è´´åº•/è¢«æ‰‹åŠ¿æ¡é®æŒ¡
          Blank().height(24)
        }
        .width('100%')
        // å…³é”®ï¼šè®©å†…å®¹ä»é¡¶éƒ¨å¼€å§‹æ’å¸ƒï¼ˆé¿å…ç©ºæ•°æ®æ—¶æ ‡é¢˜â€œè·‘ä¸­é—´â€çš„é”™è§‰ï¼‰
        .justifyContent(FlexAlign.Start)
        .alignItems(HorizontalAlign.Center)
      }
      .width('100%')
      .layoutWeight(1)
      .scrollBar(BarState.Off)
      .backgroundColor('#EEEEEE')
    }
    .width('100%')
    .height('100%')
    // ä¸ä½ é¡¹ç›®æ•´ä½“ä¸€è‡´çš„æ¸å˜èƒŒæ™¯ï¼ˆå¯æŒ‰éœ€åˆ é™¤ï¼‰
    .linearGradient({
      angle: 180,
      colors: [
        [0xFF2EC7A8, 0.0],
        [0xFFA0EACD, 0.35],
        [0xFFF5FFFC, 0.5],
        [0xFFFFFFFF, 1.0]
      ]
    })
    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM]);
  }
}
